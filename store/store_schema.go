/*
  This code was generated by the Doctor ORM Generator and isn't meant to be edited.
	If at all possible, please regenerate this file from your gp files instead of
	attempting to edit it to add changes.
*/

package store

import (
	"fmt"
	"strings"

	"github.com/acsellers/dr/schema"
)

func DefaultInt(col string) schema.Column {
	return schema.Column{Name: col, Type: "integer", Length: 10}
}

func DefaultString(col string) schema.Column {
	return schema.Column{Name: col, Type: "varchar", Length: 255}
}

func DefaultBool(col string) schema.Column {
	return schema.Column{Name: col, Type: "bool"}
}

func DefaultTime(col string) schema.Column {
	return schema.Column{Name: col, Type: "timestamp"}
}

func createRecord(c *Conn, cols []string, vals []interface{}, name, pkname string) (int, error) {
	sql := fmt.Sprintf(
		"INSERT INTO %s (%s) VALUES (%s)",
		c.SQLTable(name),
		strings.Join(cols, ", "),
		questions(len(cols)),
	)
	if c.returning {
		sql += " RETURNING " + c.SQLColumn(name, pkname)
		var pk int
		row := c.QueryRow(sql, vals...)
		err := row.Scan(&pk)
		return pk, err
	} else {
		result, err := c.Exec(sql, vals...)
		if err != nil {
			return 0, err
		}

		id, err := result.LastInsertId()
		return int(id), err
	}
}

func updateRecord(c *Conn, cols []string, vals []interface{}, name, pkname string) error {
	sql := fmt.Sprintf(
		"UPDATE %s SET %s WHERE %s=?",
		c.SQLTable(name),
		strings.Join(cols, ", "),
		c.SQLColumn(name, pkname),
	)
	_, err := c.Exec(sql, vals...)
	return err
}

func deleteRecord(c *Conn, val interface{}, name, pkname string) error {
	sql := fmt.Sprintf(
		"DELETE FROM %s WHERE %s = ?",
		c.SQLTable(name),
		c.SQLColumn(name, pkname),
	)
	_, err := c.Exec(sql, val)
	return err

}

var Schema = schema.Schema{
	Tables: map[string]*schema.Table{

		"User": &schema.Table{
			Name: "User",
			Columns: []schema.Column{

				DefaultInt("ID"),

				DefaultString("Name"),

				DefaultString("Email"),

				DefaultString("Password"),

				schema.Column{
					Name:   "CreatedAt",
					Type:   "timestamp",
					Length: 0,
				},

				DefaultBool("Management"),
			},
		},

		"Blog": &schema.Table{
			Name: "Blog",
			Columns: []schema.Column{

				DefaultInt("ID"),

				DefaultString("Name"),

				DefaultString("About"),
			},
		},

		"BlogAuthor": &schema.Table{
			Name: "BlogAuthor",
			Columns: []schema.Column{

				DefaultInt("ID"),

				DefaultBool("Admin"),

				DefaultInt("BlogID"),

				DefaultInt("UserID"),
			},
		},

		"Post": &schema.Table{
			Name: "Post",
			Columns: []schema.Column{

				DefaultInt("ID"),

				DefaultString("Title"),

				DefaultString("Permalink"),

				DefaultString("Text"),

				schema.Column{
					Name:   "CreatedAt",
					Type:   "timestamp",
					Length: 0,
				},

				schema.Column{
					Name:   "PostedAt",
					Type:   "timestamp",
					Length: 0,
				},

				DefaultInt("UserID"),

				DefaultInt("BlogID"),
			},
		},

		"Comment": &schema.Table{
			Name: "Comment",
			Columns: []schema.Column{

				DefaultInt("ID"),

				DefaultString("Text"),

				DefaultInt("UserID"),

				DefaultInt("PostID"),
			},
		},
	},
}

func init() {

	Schema.Tables["User"].HasMany = []schema.ManyRelationship{

		schema.ManyRelationship{
			Schema.Tables["User"],
			Schema.Tables["BlogAuthor"],
			Schema.Tables["BlogAuthor"].FindColumn("UserID"),
		},

		schema.ManyRelationship{
			Schema.Tables["User"],
			Schema.Tables["Post"],
			Schema.Tables["Post"].FindColumn("UserID"),
		},

		schema.ManyRelationship{
			Schema.Tables["User"],
			Schema.Tables["Comment"],
			Schema.Tables["Comment"].FindColumn("UserID"),
		},
	}

	Schema.Tables["Blog"].HasMany = []schema.ManyRelationship{

		schema.ManyRelationship{
			Schema.Tables["Blog"],
			Schema.Tables["BlogAuthor"],
			Schema.Tables["BlogAuthor"].FindColumn("BlogID"),
		},

		schema.ManyRelationship{
			Schema.Tables["Blog"],
			Schema.Tables["Post"],
			Schema.Tables["Post"].FindColumn("BlogID"),
		},
	}

	Schema.Tables["Post"].HasMany = []schema.ManyRelationship{

		schema.ManyRelationship{
			Schema.Tables["Post"],
			Schema.Tables["Comment"],
			Schema.Tables["Comment"].FindColumn("PostID"),
		},
	}

	Schema.Tables["BlogAuthor"].ChildOf = []schema.ManyRelationship{

		schema.ManyRelationship{
			Schema.Tables["User"],
			Schema.Tables["BlogAuthor"],
			Schema.Tables["BlogAuthor"].FindColumn("UserID"),
		},

		schema.ManyRelationship{
			Schema.Tables["Blog"],
			Schema.Tables["BlogAuthor"],
			Schema.Tables["BlogAuthor"].FindColumn("BlogID"),
		},
	}

	Schema.Tables["Post"].ChildOf = []schema.ManyRelationship{

		schema.ManyRelationship{
			Schema.Tables["Blog"],
			Schema.Tables["Post"],
			Schema.Tables["Post"].FindColumn("BlogID"),
		},

		schema.ManyRelationship{
			Schema.Tables["User"],
			Schema.Tables["Post"],
			Schema.Tables["Post"].FindColumn("UserID"),
		},
	}

	Schema.Tables["Comment"].ChildOf = []schema.ManyRelationship{

		schema.ManyRelationship{
			Schema.Tables["Post"],
			Schema.Tables["Comment"],
			Schema.Tables["Comment"].FindColumn("PostID"),
		},

		schema.ManyRelationship{
			Schema.Tables["User"],
			Schema.Tables["Comment"],
			Schema.Tables["Comment"].FindColumn("UserID"),
		},
	}

}

func (t *User) Save(c *Conn) error {

	// check the primary key vs the zero value, if they match then
	// we will assume we have a new record
	var pkz int
	if t.ID == pkz {
		return t.create(c)
	} else {
		return t.update(c)
	}
}

func (t *User) simpleCols(c *Conn) []string {
	return []string{c.SQLColumn("User", "Name"), c.SQLColumn("User", "Email"), c.SQLColumn("User", "Password"), c.SQLColumn("User", "CreatedAt"), c.SQLColumn("User", "Management")}
}

func (t *User) simpleVals() []interface{} {
	return []interface{}{t.Name, t.Email, t.Password, t.CreatedAt, t.Management}
}

func (t *User) create(c *Conn) error {
	cols := t.simpleCols(c)
	vals := t.simpleVals()

	pk, err := createRecord(c, cols, vals, "User", "ID")
	if err == nil {
		t.ID = pk
	}
	return err
}

func (t *User) update(c *Conn) error {
	return updateRecord(c, t.simpleCols(c), append(t.simpleVals(), t.ID), "User", "ID")
}

func (t User) Delete(c *Conn) error {
	return deleteRecord(c, t.ID, "User", "ID")
}

func (t *Blog) Save(c *Conn) error {

	// check the primary key vs the zero value, if they match then
	// we will assume we have a new record
	var pkz int
	if t.ID == pkz {
		return t.create(c)
	} else {
		return t.update(c)
	}
}

func (t *Blog) simpleCols(c *Conn) []string {
	return []string{c.SQLColumn("Blog", "Name"), c.SQLColumn("Blog", "About")}
}

func (t *Blog) simpleVals() []interface{} {
	return []interface{}{t.Name, t.About}
}

func (t *Blog) create(c *Conn) error {
	cols := t.simpleCols(c)
	vals := t.simpleVals()

	pk, err := createRecord(c, cols, vals, "Blog", "ID")
	if err == nil {
		t.ID = pk
	}
	return err
}

func (t *Blog) update(c *Conn) error {
	return updateRecord(c, t.simpleCols(c), append(t.simpleVals(), t.ID), "Blog", "ID")
}

func (t Blog) Delete(c *Conn) error {
	return deleteRecord(c, t.ID, "Blog", "ID")
}

func (t *BlogAuthor) Save(c *Conn) error {

	// check the primary key vs the zero value, if they match then
	// we will assume we have a new record
	var pkz int
	if t.ID == pkz {
		return t.create(c)
	} else {
		return t.update(c)
	}
}

func (t *BlogAuthor) simpleCols(c *Conn) []string {
	return []string{c.SQLColumn("BlogAuthor", "Admin"), c.SQLColumn("BlogAuthor", "BlogID"), c.SQLColumn("BlogAuthor", "UserID")}
}

func (t *BlogAuthor) simpleVals() []interface{} {
	return []interface{}{t.Admin, t.BlogID, t.UserID}
}

func (t *BlogAuthor) create(c *Conn) error {
	cols := t.simpleCols(c)
	vals := t.simpleVals()

	pk, err := createRecord(c, cols, vals, "BlogAuthor", "ID")
	if err == nil {
		t.ID = pk
	}
	return err
}

func (t *BlogAuthor) update(c *Conn) error {
	return updateRecord(c, t.simpleCols(c), append(t.simpleVals(), t.ID), "BlogAuthor", "ID")
}

func (t BlogAuthor) Delete(c *Conn) error {
	return deleteRecord(c, t.ID, "BlogAuthor", "ID")
}

func (t *Post) Save(c *Conn) error {

	// check the primary key vs the zero value, if they match then
	// we will assume we have a new record
	var pkz int
	if t.ID == pkz {
		return t.create(c)
	} else {
		return t.update(c)
	}
}

func (t *Post) simpleCols(c *Conn) []string {
	return []string{c.SQLColumn("Post", "Title"), c.SQLColumn("Post", "Permalink"), c.SQLColumn("Post", "Text"), c.SQLColumn("Post", "CreatedAt"), c.SQLColumn("Post", "PostedAt"), c.SQLColumn("Post", "UserID"), c.SQLColumn("Post", "BlogID")}
}

func (t *Post) simpleVals() []interface{} {
	return []interface{}{t.Title, t.Permalink, t.Text, t.CreatedAt, t.PostedAt, t.UserID, t.BlogID}
}

func (t *Post) create(c *Conn) error {
	cols := t.simpleCols(c)
	vals := t.simpleVals()

	pk, err := createRecord(c, cols, vals, "Post", "ID")
	if err == nil {
		t.ID = pk
	}
	return err
}

func (t *Post) update(c *Conn) error {
	return updateRecord(c, t.simpleCols(c), append(t.simpleVals(), t.ID), "Post", "ID")
}

func (t Post) Delete(c *Conn) error {
	return deleteRecord(c, t.ID, "Post", "ID")
}

func (t *Comment) Save(c *Conn) error {

	// check the primary key vs the zero value, if they match then
	// we will assume we have a new record
	var pkz int
	if t.ID == pkz {
		return t.create(c)
	} else {
		return t.update(c)
	}
}

func (t *Comment) simpleCols(c *Conn) []string {
	return []string{c.SQLColumn("Comment", "Text"), c.SQLColumn("Comment", "UserID"), c.SQLColumn("Comment", "PostID")}
}

func (t *Comment) simpleVals() []interface{} {
	return []interface{}{t.Text, t.UserID, t.PostID}
}

func (t *Comment) create(c *Conn) error {
	cols := t.simpleCols(c)
	vals := t.simpleVals()

	pk, err := createRecord(c, cols, vals, "Comment", "ID")
	if err == nil {
		t.ID = pk
	}
	return err
}

func (t *Comment) update(c *Conn) error {
	return updateRecord(c, t.simpleCols(c), append(t.simpleVals(), t.ID), "Comment", "ID")
}

func (t Comment) Delete(c *Conn) error {
	return deleteRecord(c, t.ID, "Comment", "ID")
}
