/*
  This code was generated by the Doc ORM Generator and isn't meant to be edited.
	If at all possible, please regenerate this file from your gp files instead of
	attempting to edit it to add changes.
*/

package store

import (
	"database/sql"
	"fmt"
	"log"
	"reflect"
	"strconv"
	"strings"
	"time"
)

type Scope interface {
	condSQL() (string, []interface{})
	QuerySQL() (string, []interface{})
	UpdateSQL() (string, []interface{})
	DeleteSQL() (string, []interface{})
	scopeName() string
	Conn() *Conn
	SetConn(*Conn) Scope
	joinOn(string, Scope) (string, bool)
	joinable() string
	joinTable() string
	conds() []condition
}

type Conn struct {
	*sql.DB
	AppConfig
	reformat  bool
	returning bool
	Log       *log.Logger

	User UserScope

	Blog BlogScope

	BlogAuthor BlogAuthorScope

	Post PostScope

	Comment CommentScope
}

func Open(driverName, dataSourceName string) (*Conn, error) {
	c := &Conn{}
	if driverName == "postgres" {
		c.reformat = true
		c.returning = true
	}
	var err error
	c.DB, err = sql.Open(driverName, dataSourceName)
	if err != nil {
		return nil, err
	}

	c.User = NewUserScope(c)

	c.Blog = NewBlogScope(c)

	c.BlogAuthor = NewBlogAuthorScope(c)

	c.Post = NewPostScope(c)

	c.Comment = NewCommentScope(c)

	return c, nil
}

func (c *Conn) Clone() *Conn {
	c2 := &Conn{
		DB:        c.DB,
		AppConfig: c.AppConfig,
		reformat:  c.reformat,
		returning: c.returning,
		Log:       c.Log,
	}

	c2.User = NewUserScope(c2)

	c2.Blog = NewBlogScope(c2)

	c2.BlogAuthor = NewBlogAuthorScope(c2)

	c2.Post = NewPostScope(c2)

	c2.Comment = NewCommentScope(c2)

	return c2
}

func (c *Conn) Exec(query string, args ...interface{}) (sql.Result, error) {
	if c.Log != nil {
		c.Log.Printf("%s %v", query, args)
	}
	return c.DB.Exec(c.FormatQuery(query), args...)
}

func (c *Conn) Query(query string, args ...interface{}) (*sql.Rows, error) {
	if c.Log != nil {
		c.Log.Printf("%s %v", query, args)
	}
	return c.DB.Query(c.FormatQuery(query), args...)
}

func (c *Conn) QueryRow(query string, args ...interface{}) *sql.Row {
	if c.Log != nil {
		c.Log.Printf("%s %v", query, args)
	}
	return c.DB.QueryRow(c.FormatQuery(query), args...)
}

func (c *Conn) FormatQuery(query string) string {
	if !c.reformat {
		return query
	}

	parts := strings.Split(query, "?")
	var newQuery []string
	for i, part := range parts[:len(parts)-1] {
		newQuery = append(newQuery, fmt.Sprintf("%s$%d", part, i+1))
	}
	newQuery = append(newQuery, parts[len(parts)-1])

	return strings.Join(newQuery, "")
}

func (c *Conn) Close() error {
	return c.DB.Close()
}

type AppConfig struct {
	defaultConfig
}

type defaultConfig struct {
	SpecialTables  map[string]string
	SpecialColumns map[string]map[string]string
}

func (c *defaultConfig) SQLTable(table string) string {
	if c == nil || c.SpecialTables[table] == "" {
		return strings.ToLower(table)
	}
	return c.SpecialTables[table]
}

func (c *defaultConfig) SQLColumn(table, column string) string {
	if c == nil || c.SpecialColumns[table] == nil || c.SpecialColumns[table][column] == "" {
		return strings.ToLower(column)
	}
	return c.SpecialColumns[table][column]
}

type UserScope struct {
	internalScope
}

func NewUserScope(c *Conn) UserScope {
	return UserScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("User"),
			currentColumn: c.SQLTable("User") + "." + c.SQLColumn("User", "ID"),
		},
	}
}

func (scope UserScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (UserScope) scopeName() string {
	return "User"
}

// basic conditions
func (scope UserScope) Eq(val interface{}) UserScope {
	return UserScope{scope.internalScope.Eq(val)}
}

func (scope UserScope) Neq(val interface{}) UserScope {
	return UserScope{scope.internalScope.Neq(val)}
}

func (scope UserScope) Gt(val interface{}) UserScope {
	return UserScope{scope.internalScope.Gt(val)}
}

func (scope UserScope) Gte(val interface{}) UserScope {
	return UserScope{scope.internalScope.Gte(val)}
}

func (scope UserScope) Lt(val interface{}) UserScope {
	return UserScope{scope.internalScope.Lt(val)}
}

func (scope UserScope) Lte(val interface{}) UserScope {
	return UserScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope UserScope) Between(lower, upper interface{}) UserScope {
	return UserScope{scope.internalScope.Between(lower, upper)}
}

func (scope UserScope) In(vals ...interface{}) UserScope {
	return UserScope{scope.internalScope.In(vals...)}
}

func (scope UserScope) NotIn(vals ...interface{}) UserScope {
	return UserScope{scope.internalScope.NotIn(vals...)}
}

func (scope UserScope) Like(str string) UserScope {
	return UserScope{scope.internalScope.Like(str)}
}

func (scope UserScope) Where(sql string, vals ...interface{}) UserScope {
	return UserScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope UserScope) Order(ordering string) UserScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope UserScope) Desc() UserScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope UserScope) Asc() UserScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope UserScope) OuterJoin(things ...Scope) UserScope {
	return UserScope{scope.internalScope.outerJoin("User", things...)}
}

func (scope UserScope) InnerJoin(things ...Scope) UserScope {
	return UserScope{scope.internalScope.innerJoin("User", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope UserScope) JoinBy(joins string, joinedScopes ...Scope) UserScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope UserScope) joinable() string {
	if scope.currentAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("User"),
			scope.currentAlias,
		)
	}
	return scope.conn.SQLTable("User")
}

func (scope UserScope) joinTable() string {
	if scope.currentAlias != "" {
		return scope.currentAlias
	}
	return scope.conn.SQLTable("User")
}

// aggregation filtering
func (scope UserScope) Having(sql string, vals ...interface{}) UserScope {
	scope.having = append(scope.having, sql)
	scope.havevals = append(scope.havevals, vals...)
	return scope
}

func (scope UserScope) GroupBySQL(cols ...string) UserScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope UserScope) Limit(limit int64) UserScope {
	scope.limit = &limit
	return scope
}

func (scope UserScope) Offset(offset int64) UserScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope UserScope) Clear() UserScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope UserScope) ClearAll() UserScope {
	scope.conditions = []condition{}
	return scope
}

func (scope UserScope) Base() UserScope {
	return NewUserScope(scope.conn)
}

// struct saving and loading
func (scope UserScope) Find(id interface{}) (User, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope UserScope) Retrieve() (User, error) {
	val := &User{}
	m := mapperForUser(scope.conn, scope.includes)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	return *val, err

}

func (scope UserScope) RetrieveAll() ([]User, error) {
	m := mapperForUser(scope.conn, scope.includes)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []User{}, err
	}
	defer rows.Close()

	vals := []User{}

	for rows.Next() {
		temp := &User{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []User{}, err
		}
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope UserScope) SaveAll(vals []User) error {
	for _, val := range vals {
		err := val.Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope UserScope) Set(val interface{}) UserScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("User")+".")
	scope.updates[colName] = val
	return scope
}

func (scope UserScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope UserScope) Pick(sql string) UserScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope UserScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("User", result)
}

// direct sql
func (scope UserScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope UserScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope UserScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope UserScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope UserScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope UserScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope UserScope) Clone() UserScope {
	return scope
}

func (scope UserScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope UserScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("User"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope UserScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

func (scope UserScope) As(alias string) UserScope {
	scope.currentAlias = alias
	return scope
}

func (scope UserScope) Distinct() UserScope {
	scope.isDistinct = true
	return scope
}

func (scope UserScope) And(scopes ...Scope) UserScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope UserScope) Or(scopes ...Scope) UserScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope UserScope) ID() UserScope {
	scope.currentColumn =
		scope.conn.SQLTable("User") +
			"." +
			scope.conn.SQLColumn("User", "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperUserToID struct {
	Mapper *mapperUser
}

func (m mapperUserToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope UserScope) Name() UserScope {
	scope.currentColumn =
		scope.conn.SQLTable("User") +
			"." +
			scope.conn.SQLColumn("User", "Name")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperUserToName struct {
	Mapper *mapperUser
}

func (m mapperUserToName) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Name = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Name = string(s)

	}

	return nil

}

func (scope UserScope) Email() UserScope {
	scope.currentColumn =
		scope.conn.SQLTable("User") +
			"." +
			scope.conn.SQLColumn("User", "Email")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperUserToEmail struct {
	Mapper *mapperUser
}

func (m mapperUserToEmail) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Email = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Email = string(s)

	}

	return nil

}

func (scope UserScope) Password() UserScope {
	scope.currentColumn =
		scope.conn.SQLTable("User") +
			"." +
			scope.conn.SQLColumn("User", "Password")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperUserToPassword struct {
	Mapper *mapperUser
}

func (m mapperUserToPassword) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Password = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Password = string(s)

	}

	return nil

}

func (scope UserScope) CreatedAt() UserScope {
	scope.currentColumn =
		scope.conn.SQLTable("User") +
			"." +
			scope.conn.SQLColumn("User", "CreatedAt")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperUserToCreatedAt struct {
	Mapper *mapperUser
}

func (m mapperUserToCreatedAt) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(time.Time); ok {

		(*m.Mapper.Current).CreatedAt = s

	}

	return nil

}

func (scope UserScope) Management() UserScope {
	scope.currentColumn =
		scope.conn.SQLTable("User") +
			"." +
			scope.conn.SQLColumn("User", "Management")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperUserToManagement struct {
	Mapper *mapperUser
}

func (m mapperUserToManagement) Scan(v interface{}) error {

	if v == nil {
		// it is false or null, the zero values
	} else if b, ok := v.(bool); ok {

		(*m.Mapper.Current).Management = b

	} else if i, ok := v.(int64); ok {

		if i != 0 {
			(*m.Mapper.Current).Management = true
		}

	}

	return nil

}

type mapperUser struct {
	Current  **User
	Columns  []string
	Scanners []interface{}
}

func mapperForUser(c *Conn, includes []string) *mapperUser {
	m := &mapperUser{}
	m.Columns = []string{c.SQLTable("User") + "." + c.SQLColumn("User", "ID"), c.SQLTable("User") + "." + c.SQLColumn("User", "Name"), c.SQLTable("User") + "." + c.SQLColumn("User", "Email"), c.SQLTable("User") + "." + c.SQLColumn("User", "Password"), c.SQLTable("User") + "." + c.SQLColumn("User", "CreatedAt"), c.SQLTable("User") + "." + c.SQLColumn("User", "Management")}
	m.Scanners = []interface{}{

		mapperUserToID{m},

		mapperUserToName{m},

		mapperUserToEmail{m},

		mapperUserToPassword{m},

		mapperUserToCreatedAt{m},

		mapperUserToManagement{m},
	}

	return m
}

type BlogScope struct {
	internalScope
}

func NewBlogScope(c *Conn) BlogScope {
	return BlogScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("Blog"),
			currentColumn: c.SQLTable("Blog") + "." + c.SQLColumn("Blog", "ID"),
		},
	}
}

func (scope BlogScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (BlogScope) scopeName() string {
	return "Blog"
}

// basic conditions
func (scope BlogScope) Eq(val interface{}) BlogScope {
	return BlogScope{scope.internalScope.Eq(val)}
}

func (scope BlogScope) Neq(val interface{}) BlogScope {
	return BlogScope{scope.internalScope.Neq(val)}
}

func (scope BlogScope) Gt(val interface{}) BlogScope {
	return BlogScope{scope.internalScope.Gt(val)}
}

func (scope BlogScope) Gte(val interface{}) BlogScope {
	return BlogScope{scope.internalScope.Gte(val)}
}

func (scope BlogScope) Lt(val interface{}) BlogScope {
	return BlogScope{scope.internalScope.Lt(val)}
}

func (scope BlogScope) Lte(val interface{}) BlogScope {
	return BlogScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope BlogScope) Between(lower, upper interface{}) BlogScope {
	return BlogScope{scope.internalScope.Between(lower, upper)}
}

func (scope BlogScope) In(vals ...interface{}) BlogScope {
	return BlogScope{scope.internalScope.In(vals...)}
}

func (scope BlogScope) NotIn(vals ...interface{}) BlogScope {
	return BlogScope{scope.internalScope.NotIn(vals...)}
}

func (scope BlogScope) Like(str string) BlogScope {
	return BlogScope{scope.internalScope.Like(str)}
}

func (scope BlogScope) Where(sql string, vals ...interface{}) BlogScope {
	return BlogScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope BlogScope) Order(ordering string) BlogScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope BlogScope) Desc() BlogScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope BlogScope) Asc() BlogScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope BlogScope) OuterJoin(things ...Scope) BlogScope {
	return BlogScope{scope.internalScope.outerJoin("Blog", things...)}
}

func (scope BlogScope) InnerJoin(things ...Scope) BlogScope {
	return BlogScope{scope.internalScope.innerJoin("Blog", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope BlogScope) JoinBy(joins string, joinedScopes ...Scope) BlogScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope BlogScope) joinable() string {
	if scope.currentAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("Blog"),
			scope.currentAlias,
		)
	}
	return scope.conn.SQLTable("Blog")
}

func (scope BlogScope) joinTable() string {
	if scope.currentAlias != "" {
		return scope.currentAlias
	}
	return scope.conn.SQLTable("Blog")
}

// aggregation filtering
func (scope BlogScope) Having(sql string, vals ...interface{}) BlogScope {
	scope.having = append(scope.having, sql)
	scope.havevals = append(scope.havevals, vals...)
	return scope
}

func (scope BlogScope) GroupBySQL(cols ...string) BlogScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope BlogScope) Limit(limit int64) BlogScope {
	scope.limit = &limit
	return scope
}

func (scope BlogScope) Offset(offset int64) BlogScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope BlogScope) Clear() BlogScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope BlogScope) ClearAll() BlogScope {
	scope.conditions = []condition{}
	return scope
}

func (scope BlogScope) Base() BlogScope {
	return NewBlogScope(scope.conn)
}

// struct saving and loading
func (scope BlogScope) Find(id interface{}) (Blog, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope BlogScope) Retrieve() (Blog, error) {
	val := &Blog{}
	m := mapperForBlog(scope.conn, scope.includes)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	return *val, err

}

func (scope BlogScope) RetrieveAll() ([]Blog, error) {
	m := mapperForBlog(scope.conn, scope.includes)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []Blog{}, err
	}
	defer rows.Close()

	vals := []Blog{}

	for rows.Next() {
		temp := &Blog{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []Blog{}, err
		}
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope BlogScope) SaveAll(vals []Blog) error {
	for _, val := range vals {
		err := val.Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope BlogScope) Set(val interface{}) BlogScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("Blog")+".")
	scope.updates[colName] = val
	return scope
}

func (scope BlogScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope BlogScope) Pick(sql string) BlogScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope BlogScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("Blog", result)
}

// direct sql
func (scope BlogScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope BlogScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope BlogScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope BlogScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope BlogScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope BlogScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope BlogScope) Clone() BlogScope {
	return scope
}

func (scope BlogScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope BlogScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("Blog"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope BlogScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

func (scope BlogScope) As(alias string) BlogScope {
	scope.currentAlias = alias
	return scope
}

func (scope BlogScope) Distinct() BlogScope {
	scope.isDistinct = true
	return scope
}

func (scope BlogScope) And(scopes ...Scope) BlogScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope BlogScope) Or(scopes ...Scope) BlogScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope BlogScope) ID() BlogScope {
	scope.currentColumn =
		scope.conn.SQLTable("Blog") +
			"." +
			scope.conn.SQLColumn("Blog", "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogToID struct {
	Mapper *mapperBlog
}

func (m mapperBlogToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope BlogScope) Name() BlogScope {
	scope.currentColumn =
		scope.conn.SQLTable("Blog") +
			"." +
			scope.conn.SQLColumn("Blog", "Name")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogToName struct {
	Mapper *mapperBlog
}

func (m mapperBlogToName) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Name = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Name = string(s)

	}

	return nil

}

func (scope BlogScope) About() BlogScope {
	scope.currentColumn =
		scope.conn.SQLTable("Blog") +
			"." +
			scope.conn.SQLColumn("Blog", "About")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogToAbout struct {
	Mapper *mapperBlog
}

func (m mapperBlogToAbout) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).About = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).About = string(s)

	}

	return nil

}

type mapperBlog struct {
	Current  **Blog
	Columns  []string
	Scanners []interface{}
}

func mapperForBlog(c *Conn, includes []string) *mapperBlog {
	m := &mapperBlog{}
	m.Columns = []string{c.SQLTable("Blog") + "." + c.SQLColumn("Blog", "ID"), c.SQLTable("Blog") + "." + c.SQLColumn("Blog", "Name"), c.SQLTable("Blog") + "." + c.SQLColumn("Blog", "About")}
	m.Scanners = []interface{}{

		mapperBlogToID{m},

		mapperBlogToName{m},

		mapperBlogToAbout{m},
	}

	return m
}

type BlogAuthorScope struct {
	internalScope
}

func NewBlogAuthorScope(c *Conn) BlogAuthorScope {
	return BlogAuthorScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("BlogAuthor"),
			currentColumn: c.SQLTable("BlogAuthor") + "." + c.SQLColumn("BlogAuthor", "ID"),
		},
	}
}

func (scope BlogAuthorScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (BlogAuthorScope) scopeName() string {
	return "BlogAuthor"
}

// basic conditions
func (scope BlogAuthorScope) Eq(val interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Eq(val)}
}

func (scope BlogAuthorScope) Neq(val interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Neq(val)}
}

func (scope BlogAuthorScope) Gt(val interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Gt(val)}
}

func (scope BlogAuthorScope) Gte(val interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Gte(val)}
}

func (scope BlogAuthorScope) Lt(val interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Lt(val)}
}

func (scope BlogAuthorScope) Lte(val interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope BlogAuthorScope) Between(lower, upper interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Between(lower, upper)}
}

func (scope BlogAuthorScope) In(vals ...interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.In(vals...)}
}

func (scope BlogAuthorScope) NotIn(vals ...interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.NotIn(vals...)}
}

func (scope BlogAuthorScope) Like(str string) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Like(str)}
}

func (scope BlogAuthorScope) Where(sql string, vals ...interface{}) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope BlogAuthorScope) Order(ordering string) BlogAuthorScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope BlogAuthorScope) Desc() BlogAuthorScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope BlogAuthorScope) Asc() BlogAuthorScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope BlogAuthorScope) OuterJoin(things ...Scope) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.outerJoin("BlogAuthor", things...)}
}

func (scope BlogAuthorScope) InnerJoin(things ...Scope) BlogAuthorScope {
	return BlogAuthorScope{scope.internalScope.innerJoin("BlogAuthor", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope BlogAuthorScope) JoinBy(joins string, joinedScopes ...Scope) BlogAuthorScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope BlogAuthorScope) joinable() string {
	if scope.currentAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("BlogAuthor"),
			scope.currentAlias,
		)
	}
	return scope.conn.SQLTable("BlogAuthor")
}

func (scope BlogAuthorScope) joinTable() string {
	if scope.currentAlias != "" {
		return scope.currentAlias
	}
	return scope.conn.SQLTable("BlogAuthor")
}

// aggregation filtering
func (scope BlogAuthorScope) Having(sql string, vals ...interface{}) BlogAuthorScope {
	scope.having = append(scope.having, sql)
	scope.havevals = append(scope.havevals, vals...)
	return scope
}

func (scope BlogAuthorScope) GroupBySQL(cols ...string) BlogAuthorScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope BlogAuthorScope) Limit(limit int64) BlogAuthorScope {
	scope.limit = &limit
	return scope
}

func (scope BlogAuthorScope) Offset(offset int64) BlogAuthorScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope BlogAuthorScope) Clear() BlogAuthorScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope BlogAuthorScope) ClearAll() BlogAuthorScope {
	scope.conditions = []condition{}
	return scope
}

func (scope BlogAuthorScope) Base() BlogAuthorScope {
	return NewBlogAuthorScope(scope.conn)
}

// struct saving and loading
func (scope BlogAuthorScope) Find(id interface{}) (BlogAuthor, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope BlogAuthorScope) Retrieve() (BlogAuthor, error) {
	val := &BlogAuthor{}
	m := mapperForBlogAuthor(scope.conn, scope.includes)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	return *val, err

}

func (scope BlogAuthorScope) RetrieveAll() ([]BlogAuthor, error) {
	m := mapperForBlogAuthor(scope.conn, scope.includes)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []BlogAuthor{}, err
	}
	defer rows.Close()

	vals := []BlogAuthor{}

	for rows.Next() {
		temp := &BlogAuthor{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []BlogAuthor{}, err
		}
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope BlogAuthorScope) SaveAll(vals []BlogAuthor) error {
	for _, val := range vals {
		err := val.Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope BlogAuthorScope) Set(val interface{}) BlogAuthorScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("BlogAuthor")+".")
	scope.updates[colName] = val
	return scope
}

func (scope BlogAuthorScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope BlogAuthorScope) Pick(sql string) BlogAuthorScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope BlogAuthorScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("BlogAuthor", result)
}

// direct sql
func (scope BlogAuthorScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope BlogAuthorScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope BlogAuthorScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope BlogAuthorScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope BlogAuthorScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope BlogAuthorScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope BlogAuthorScope) Clone() BlogAuthorScope {
	return scope
}

func (scope BlogAuthorScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope BlogAuthorScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("BlogAuthor"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope BlogAuthorScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

func (scope BlogAuthorScope) As(alias string) BlogAuthorScope {
	scope.currentAlias = alias
	return scope
}

func (scope BlogAuthorScope) Distinct() BlogAuthorScope {
	scope.isDistinct = true
	return scope
}

func (scope BlogAuthorScope) And(scopes ...Scope) BlogAuthorScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope BlogAuthorScope) Or(scopes ...Scope) BlogAuthorScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope BlogAuthorScope) ID() BlogAuthorScope {
	scope.currentColumn =
		scope.conn.SQLTable("BlogAuthor") +
			"." +
			scope.conn.SQLColumn("BlogAuthor", "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogAuthorToID struct {
	Mapper *mapperBlogAuthor
}

func (m mapperBlogAuthorToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope BlogAuthorScope) Admin() BlogAuthorScope {
	scope.currentColumn =
		scope.conn.SQLTable("BlogAuthor") +
			"." +
			scope.conn.SQLColumn("BlogAuthor", "Admin")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogAuthorToAdmin struct {
	Mapper *mapperBlogAuthor
}

func (m mapperBlogAuthorToAdmin) Scan(v interface{}) error {

	if v == nil {
		// it is false or null, the zero values
	} else if b, ok := v.(bool); ok {

		(*m.Mapper.Current).Admin = b

	} else if i, ok := v.(int64); ok {

		if i != 0 {
			(*m.Mapper.Current).Admin = true
		}

	}

	return nil

}

func (scope BlogAuthorScope) BlogID() BlogAuthorScope {
	scope.currentColumn =
		scope.conn.SQLTable("BlogAuthor") +
			"." +
			scope.conn.SQLColumn("BlogAuthor", "BlogID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogAuthorToBlogID struct {
	Mapper *mapperBlogAuthor
}

func (m mapperBlogAuthorToBlogID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).BlogID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope BlogAuthorScope) UserID() BlogAuthorScope {
	scope.currentColumn =
		scope.conn.SQLTable("BlogAuthor") +
			"." +
			scope.conn.SQLColumn("BlogAuthor", "UserID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperBlogAuthorToUserID struct {
	Mapper *mapperBlogAuthor
}

func (m mapperBlogAuthorToUserID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).UserID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

type mapperBlogAuthor struct {
	Current  **BlogAuthor
	Columns  []string
	Scanners []interface{}
}

func mapperForBlogAuthor(c *Conn, includes []string) *mapperBlogAuthor {
	m := &mapperBlogAuthor{}
	m.Columns = []string{c.SQLTable("BlogAuthor") + "." + c.SQLColumn("BlogAuthor", "ID"), c.SQLTable("BlogAuthor") + "." + c.SQLColumn("BlogAuthor", "Admin"), c.SQLTable("BlogAuthor") + "." + c.SQLColumn("BlogAuthor", "BlogID"), c.SQLTable("BlogAuthor") + "." + c.SQLColumn("BlogAuthor", "UserID")}
	m.Scanners = []interface{}{

		mapperBlogAuthorToID{m},

		mapperBlogAuthorToAdmin{m},

		mapperBlogAuthorToBlogID{m},

		mapperBlogAuthorToUserID{m},
	}

	return m
}

type PostScope struct {
	internalScope
}

func NewPostScope(c *Conn) PostScope {
	return PostScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("Post"),
			currentColumn: c.SQLTable("Post") + "." + c.SQLColumn("Post", "ID"),
		},
	}
}

func (scope PostScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (PostScope) scopeName() string {
	return "Post"
}

// basic conditions
func (scope PostScope) Eq(val interface{}) PostScope {
	return PostScope{scope.internalScope.Eq(val)}
}

func (scope PostScope) Neq(val interface{}) PostScope {
	return PostScope{scope.internalScope.Neq(val)}
}

func (scope PostScope) Gt(val interface{}) PostScope {
	return PostScope{scope.internalScope.Gt(val)}
}

func (scope PostScope) Gte(val interface{}) PostScope {
	return PostScope{scope.internalScope.Gte(val)}
}

func (scope PostScope) Lt(val interface{}) PostScope {
	return PostScope{scope.internalScope.Lt(val)}
}

func (scope PostScope) Lte(val interface{}) PostScope {
	return PostScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope PostScope) Between(lower, upper interface{}) PostScope {
	return PostScope{scope.internalScope.Between(lower, upper)}
}

func (scope PostScope) In(vals ...interface{}) PostScope {
	return PostScope{scope.internalScope.In(vals...)}
}

func (scope PostScope) NotIn(vals ...interface{}) PostScope {
	return PostScope{scope.internalScope.NotIn(vals...)}
}

func (scope PostScope) Like(str string) PostScope {
	return PostScope{scope.internalScope.Like(str)}
}

func (scope PostScope) Where(sql string, vals ...interface{}) PostScope {
	return PostScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope PostScope) Order(ordering string) PostScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope PostScope) Desc() PostScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope PostScope) Asc() PostScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope PostScope) OuterJoin(things ...Scope) PostScope {
	return PostScope{scope.internalScope.outerJoin("Post", things...)}
}

func (scope PostScope) InnerJoin(things ...Scope) PostScope {
	return PostScope{scope.internalScope.innerJoin("Post", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope PostScope) JoinBy(joins string, joinedScopes ...Scope) PostScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope PostScope) joinable() string {
	if scope.currentAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("Post"),
			scope.currentAlias,
		)
	}
	return scope.conn.SQLTable("Post")
}

func (scope PostScope) joinTable() string {
	if scope.currentAlias != "" {
		return scope.currentAlias
	}
	return scope.conn.SQLTable("Post")
}

// aggregation filtering
func (scope PostScope) Having(sql string, vals ...interface{}) PostScope {
	scope.having = append(scope.having, sql)
	scope.havevals = append(scope.havevals, vals...)
	return scope
}

func (scope PostScope) GroupBySQL(cols ...string) PostScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope PostScope) Limit(limit int64) PostScope {
	scope.limit = &limit
	return scope
}

func (scope PostScope) Offset(offset int64) PostScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope PostScope) Clear() PostScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope PostScope) ClearAll() PostScope {
	scope.conditions = []condition{}
	return scope
}

func (scope PostScope) Base() PostScope {
	return NewPostScope(scope.conn)
}

// struct saving and loading
func (scope PostScope) Find(id interface{}) (Post, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope PostScope) Retrieve() (Post, error) {
	val := &Post{}
	m := mapperForPost(scope.conn, scope.includes)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	return *val, err

}

func (scope PostScope) RetrieveAll() ([]Post, error) {
	m := mapperForPost(scope.conn, scope.includes)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []Post{}, err
	}
	defer rows.Close()

	vals := []Post{}

	for rows.Next() {
		temp := &Post{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []Post{}, err
		}
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope PostScope) SaveAll(vals []Post) error {
	for _, val := range vals {
		err := val.Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope PostScope) Set(val interface{}) PostScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("Post")+".")
	scope.updates[colName] = val
	return scope
}

func (scope PostScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope PostScope) Pick(sql string) PostScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope PostScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("Post", result)
}

// direct sql
func (scope PostScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope PostScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope PostScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope PostScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope PostScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope PostScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope PostScope) Clone() PostScope {
	return scope
}

func (scope PostScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope PostScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("Post"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope PostScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

func (scope PostScope) As(alias string) PostScope {
	scope.currentAlias = alias
	return scope
}

func (scope PostScope) Distinct() PostScope {
	scope.isDistinct = true
	return scope
}

func (scope PostScope) And(scopes ...Scope) PostScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope PostScope) Or(scopes ...Scope) PostScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope PostScope) ID() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToID struct {
	Mapper *mapperPost
}

func (m mapperPostToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope PostScope) Title() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "Title")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToTitle struct {
	Mapper *mapperPost
}

func (m mapperPostToTitle) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Title = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Title = string(s)

	}

	return nil

}

func (scope PostScope) Permalink() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "Permalink")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToPermalink struct {
	Mapper *mapperPost
}

func (m mapperPostToPermalink) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Permalink = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Permalink = string(s)

	}

	return nil

}

func (scope PostScope) Text() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "Text")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToText struct {
	Mapper *mapperPost
}

func (m mapperPostToText) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Text = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Text = string(s)

	}

	return nil

}

func (scope PostScope) CreatedAt() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "CreatedAt")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToCreatedAt struct {
	Mapper *mapperPost
}

func (m mapperPostToCreatedAt) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(time.Time); ok {

		(*m.Mapper.Current).CreatedAt = s

	}

	return nil

}

func (scope PostScope) PostedAt() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "PostedAt")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToPostedAt struct {
	Mapper *mapperPost
}

func (m mapperPostToPostedAt) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(time.Time); ok {

		(*m.Mapper.Current).PostedAt = s

	}

	return nil

}

func (scope PostScope) UserID() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "UserID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToUserID struct {
	Mapper *mapperPost
}

func (m mapperPostToUserID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).UserID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope PostScope) BlogID() PostScope {
	scope.currentColumn =
		scope.conn.SQLTable("Post") +
			"." +
			scope.conn.SQLColumn("Post", "BlogID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperPostToBlogID struct {
	Mapper *mapperPost
}

func (m mapperPostToBlogID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).BlogID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

type mapperPost struct {
	Current  **Post
	Columns  []string
	Scanners []interface{}
}

func mapperForPost(c *Conn, includes []string) *mapperPost {
	m := &mapperPost{}
	m.Columns = []string{c.SQLTable("Post") + "." + c.SQLColumn("Post", "ID"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "Title"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "Permalink"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "Text"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "CreatedAt"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "PostedAt"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "UserID"), c.SQLTable("Post") + "." + c.SQLColumn("Post", "BlogID")}
	m.Scanners = []interface{}{

		mapperPostToID{m},

		mapperPostToTitle{m},

		mapperPostToPermalink{m},

		mapperPostToText{m},

		mapperPostToCreatedAt{m},

		mapperPostToPostedAt{m},

		mapperPostToUserID{m},

		mapperPostToBlogID{m},
	}

	return m
}

type CommentScope struct {
	internalScope
}

func NewCommentScope(c *Conn) CommentScope {
	return CommentScope{
		internalScope{
			conn:          c,
			table:         c.SQLTable("Comment"),
			currentColumn: c.SQLTable("Comment") + "." + c.SQLColumn("Comment", "ID"),
		},
	}
}

func (scope CommentScope) SetConn(conn *Conn) Scope {
	scope.conn = conn
	return scope
}

func (CommentScope) scopeName() string {
	return "Comment"
}

// basic conditions
func (scope CommentScope) Eq(val interface{}) CommentScope {
	return CommentScope{scope.internalScope.Eq(val)}
}

func (scope CommentScope) Neq(val interface{}) CommentScope {
	return CommentScope{scope.internalScope.Neq(val)}
}

func (scope CommentScope) Gt(val interface{}) CommentScope {
	return CommentScope{scope.internalScope.Gt(val)}
}

func (scope CommentScope) Gte(val interface{}) CommentScope {
	return CommentScope{scope.internalScope.Gte(val)}
}

func (scope CommentScope) Lt(val interface{}) CommentScope {
	return CommentScope{scope.internalScope.Lt(val)}
}

func (scope CommentScope) Lte(val interface{}) CommentScope {
	return CommentScope{scope.internalScope.Lte(val)}
}

// multi value conditions
func (scope CommentScope) Between(lower, upper interface{}) CommentScope {
	return CommentScope{scope.internalScope.Between(lower, upper)}
}

func (scope CommentScope) In(vals ...interface{}) CommentScope {
	return CommentScope{scope.internalScope.In(vals...)}
}

func (scope CommentScope) NotIn(vals ...interface{}) CommentScope {
	return CommentScope{scope.internalScope.NotIn(vals...)}
}

func (scope CommentScope) Like(str string) CommentScope {
	return CommentScope{scope.internalScope.Like(str)}
}

func (scope CommentScope) Where(sql string, vals ...interface{}) CommentScope {
	return CommentScope{scope.internalScope.Where(sql, vals...)}
}

// ordering conditions
func (scope CommentScope) Order(ordering string) CommentScope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope CommentScope) Desc() CommentScope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope CommentScope) Asc() CommentScope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// Join funcs
func (scope CommentScope) OuterJoin(things ...Scope) CommentScope {
	return CommentScope{scope.internalScope.outerJoin("Comment", things...)}
}

func (scope CommentScope) InnerJoin(things ...Scope) CommentScope {
	return CommentScope{scope.internalScope.innerJoin("Comment", things...)}
}

// JoinBy allows you to specify the exact join SQL statment for one or more
// tables. You can also pass the Scope objects that you are manually joining,
// which are recorded for future Joining to work off of or to be Include'd.
func (scope CommentScope) JoinBy(joins string, joinedScopes ...Scope) CommentScope {
	scope.joins = append(scope.joins, joins)
	scope.joinedScopes = append(scope.joinedScopes, joinedScopes...)
	return scope
}

func (scope CommentScope) joinable() string {
	if scope.currentAlias != "" {
		return fmt.Sprintf(
			"%s AS %s",
			scope.conn.SQLTable("Comment"),
			scope.currentAlias,
		)
	}
	return scope.conn.SQLTable("Comment")
}

func (scope CommentScope) joinTable() string {
	if scope.currentAlias != "" {
		return scope.currentAlias
	}
	return scope.conn.SQLTable("Comment")
}

// aggregation filtering
func (scope CommentScope) Having(sql string, vals ...interface{}) CommentScope {
	scope.having = append(scope.having, sql)
	scope.havevals = append(scope.havevals, vals...)
	return scope
}

func (scope CommentScope) GroupBySQL(cols ...string) CommentScope {
	scope.groupBy = append(scope.groupBy, cols...)
	return scope
}

// Result count filtering
func (scope CommentScope) Limit(limit int64) CommentScope {
	scope.limit = &limit
	return scope
}

func (scope CommentScope) Offset(offset int64) CommentScope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope CommentScope) Clear() CommentScope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope CommentScope) ClearAll() CommentScope {
	scope.conditions = []condition{}
	return scope
}

func (scope CommentScope) Base() CommentScope {
	return NewCommentScope(scope.conn)
}

// struct saving and loading
func (scope CommentScope) Find(id interface{}) (Comment, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope CommentScope) Retrieve() (Comment, error) {
	val := &Comment{}
	m := mapperForComment(scope.conn, scope.includes)
	m.Current = &val
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	row := scope.conn.QueryRow(ss, vv...)
	err := row.Scan(m.Scanners...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
	}
	return *val, err

}

func (scope CommentScope) RetrieveAll() ([]Comment, error) {
	m := mapperForComment(scope.conn, scope.includes)
	scope.columns = m.Columns

	ss, vv := scope.QuerySQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		err = fmt.Errorf("SQL: %s\n%s", ss, err.Error())
		return []Comment{}, err
	}
	defer rows.Close()

	vals := []Comment{}

	for rows.Next() {
		temp := &Comment{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []Comment{}, err
		}
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope CommentScope) SaveAll(vals []Comment) error {
	for _, val := range vals {
		err := val.Save(scope.conn)
		if err != nil {
			return err
		}
	}
	return nil
}

// Scope attribute updating
func (scope CommentScope) Set(val interface{}) CommentScope {
	if scope.updates == nil {
		scope.updates = make(map[string]interface{})
	}
	colName := strings.TrimPrefix(scope.currentColumn, scope.conn.SQLTable("Comment")+".")
	scope.updates[colName] = val
	return scope
}

func (scope CommentScope) Update() error {
	sql, vals := scope.UpdateSQL()
	_, err := scope.conn.Exec(sql, vals...)
	return err
}

// subset plucking
func (scope CommentScope) Pick(sql string) CommentScope {
	scope.isDistinct = false
	scope.currentColumn = sql

	return scope
}

func (scope CommentScope) PluckStruct(result interface{}) error {
	return scope.internalScope.pluckStruct("Comment", result)
}

// direct sql
func (scope CommentScope) Count() int64 {
	return scope.ID().Distinct().CountOf()
}

func (scope CommentScope) CountBy(sql string) int64 {
	scope.columns = []string{sql}
	ss, sv := scope.QuerySQL()
	var value int64
	row := scope.conn.QueryRow(ss, sv...)
	err := row.Scan(&value)
	if err != nil {
		panic(err)
	}

	return value
}

func (scope CommentScope) CountOf() int64 {
	if scope.isDistinct {
		return scope.CountBy(fmt.Sprintf("COUNT(DISTINCT %s)", scope.currentColumn))
	}
	return scope.CountBy(fmt.Sprintf("COUNT(%s)", scope.currentColumn))
}

func (scope CommentScope) UpdateBySQL(sql string, vals ...interface{}) error {
	scope.columns = []string{""}
	ss, sv := scope.query()
	ss = strings.TrimPrefix(ss, "SELECT FROM "+scope.table)
	ss = fmt.Sprintf("UPDATE %s SET %s %s", scope.table, sql, ss)
	_, err := scope.conn.Exec(ss, append(vals, sv...))
	return err
}

func (scope CommentScope) Delete() error {
	sql, cv := scope.DeleteSQL()
	if sql == "" {
		if err, ok := cv[0].(error); ok {
			return err
		} else {
			return fmt.Errorf("Unspecified Error in DeleteSQL()")
		}
	}
	_, err := scope.conn.Exec(sql, cv...)
	if err != nil {
		return fmt.Errorf("Encountered error: %v\nSQL: %s %v", err, sql, cv)
	}
	return nil
}
func (scope CommentScope) condSQL() (string, []interface{}) {
	conds := []string{}
	vals := []interface{}{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

// special
func (scope CommentScope) Clone() CommentScope {
	return scope
}

func (scope CommentScope) QuerySQL() (string, []interface{}) {
	return scope.query()
}

func (scope CommentScope) UpdateSQL() (string, []interface{}) {
	sql := fmt.Sprintf(
		"UPDATE %s SET ",
		scope.conn.SQLTable("Comment"),
	)

	updates := []string{}
	vals := []interface{}{}
	for col, val := range scope.updates {
		updates = append(updates, col+" = ?")
		vals = append(vals, val)
	}
	sql += strings.Join(updates, ", ")

	if len(scope.conditions) > 0 {
		cs, cv := scope.conditionSQL()
		sql += " WHERE " + cs
		vals = append(vals, cv...)
	}
	return sql, vals
}

func (scope CommentScope) DeleteSQL() (string, []interface{}) {
	delScope := scope.Clone()
	if len(scope.joins) > 0 || len(scope.having) > 0 {
		ids, err := scope.ID().Distinct().PluckInt()
		if err != nil {
			return "", []interface{}{err}
		}
		delScope = delScope.ClearAll().ID().In(ids)
	}
	cs, cv := scope.condSQL()

	if cs == "" {
		sql := fmt.Sprintf("DELETE FROM %s", scope.table, cs)
		return sql, []interface{}{}
	} else {
		sql := fmt.Sprintf("DELETE FROM %s WHERE %s", scope.table, cs)
		return sql, cv
	}
}

func (scope CommentScope) As(alias string) CommentScope {
	scope.currentAlias = alias
	return scope
}

func (scope CommentScope) Distinct() CommentScope {
	scope.isDistinct = true
	return scope
}

func (scope CommentScope) And(scopes ...Scope) CommentScope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.conds()...)
	}
	return scope
}

func (scope CommentScope) Or(scopes ...Scope) CommentScope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		conds := oscope.conds()
		if len(conds) == 1 {
			c.vals = append(c.vals, conds[0].vals...)
			ors = append(ors, conds[0].ToSQL())
		} else {
			for _, ocond := range conds {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

func (scope CommentScope) ID() CommentScope {
	scope.currentColumn =
		scope.conn.SQLTable("Comment") +
			"." +
			scope.conn.SQLColumn("Comment", "ID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCommentToID struct {
	Mapper *mapperComment
}

func (m mapperCommentToID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).ID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope CommentScope) Text() CommentScope {
	scope.currentColumn =
		scope.conn.SQLTable("Comment") +
			"." +
			scope.conn.SQLColumn("Comment", "Text")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCommentToText struct {
	Mapper *mapperComment
}

func (m mapperCommentToText) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {

		(*m.Mapper.Current).Text = s

	} else if s, ok := v.([]byte); ok {

		(*m.Mapper.Current).Text = string(s)

	}

	return nil

}

func (scope CommentScope) UserID() CommentScope {
	scope.currentColumn =
		scope.conn.SQLTable("Comment") +
			"." +
			scope.conn.SQLColumn("Comment", "UserID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCommentToUserID struct {
	Mapper *mapperComment
}

func (m mapperCommentToUserID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).UserID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

func (scope CommentScope) PostID() CommentScope {
	scope.currentColumn =
		scope.conn.SQLTable("Comment") +
			"." +
			scope.conn.SQLColumn("Comment", "PostID")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapperCommentToPostID struct {
	Mapper *mapperComment
}

func (m mapperCommentToPostID) Scan(v interface{}) error {

	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int64); ok {

		(*m.Mapper.Current).PostID = int(s)

	} else if b, ok := v.([]byte); ok {
		i, err := strconv.Atoi(string(b))

		(*m.Mapper.Current).ID = i

		return err
	}
	return nil

}

type mapperComment struct {
	Current  **Comment
	Columns  []string
	Scanners []interface{}
}

func mapperForComment(c *Conn, includes []string) *mapperComment {
	m := &mapperComment{}
	m.Columns = []string{c.SQLTable("Comment") + "." + c.SQLColumn("Comment", "ID"), c.SQLTable("Comment") + "." + c.SQLColumn("Comment", "Text"), c.SQLTable("Comment") + "." + c.SQLColumn("Comment", "UserID"), c.SQLTable("Comment") + "." + c.SQLColumn("Comment", "PostID")}
	m.Scanners = []interface{}{

		mapperCommentToID{m},

		mapperCommentToText{m},

		mapperCommentToUserID{m},

		mapperCommentToPostID{m},
	}

	return m
}

type internalScope struct {
	conn                        *Conn
	table                       string
	columns                     []string
	order                       []string
	joins                       []string
	joinedScopes                []Scope
	includes                    []string
	conditions                  []condition
	having                      []string
	havevals                    []interface{}
	groupBy                     []string
	currentColumn, currentAlias string
	isDistinct                  bool
	limit, offset               *int64
	updates                     map[string]interface{}
}

func (scope internalScope) Conn() *Conn {
	return scope.conn
}

func (scope internalScope) conds() []condition {
	return scope.conditions
}

func (s *internalScope) query() (string, []interface{}) {
	// SELECT (columns) FROM (table) (joins) WHERE (conditions)
	// GROUP BY (grouping) HAVING (havings)
	// ORDER BY (orderings) LIMIT (limit) OFFSET (offset)
	sql := []string{}
	vals := []interface{}{}
	if len(s.columns) == 0 {
		sql = append(sql, "SELECT", s.table+".*")
	} else {
		sql = append(sql, "SELECT", strings.Join(s.columns, ", "))
	}
	// if s.source == nil { // subquery
	//
	// } else {
	sql = append(sql, "FROM", s.table)
	// }
	sql = append(sql, s.joins...)

	if len(s.conditions) > 0 {
		cs, cv := s.conditionSQL()
		sql = append(sql, "WHERE", cs)
		vals = append(vals, cv...)
	}

	// if len(s.groupings) > 0 {
	//   sql = append(sql , "GROUP BY")
	//   for _, grouping := range s.groupings {
	//     sql = append(sql, grouping.QuerySQL()
	//   }
	// }

	if len(s.having) > 0 {
		sql = append(sql, "HAVING")
		sql = append(sql, s.having...)
		vals = append(vals, s.havevals...)
	}

	if len(s.order) > 0 {
		sql = append(sql, "ORDER BY")
		sql = append(sql, s.order...)
	}

	if s.limit != nil {
		sql = append(sql, "LIMIT", fmt.Sprintf("%v", *s.limit))
	}

	if s.offset != nil {
		sql = append(sql, "OFFSET", fmt.Sprintf("%v", *s.offset))
	}

	return strings.Join(sql, " "), vals
}

func (scope internalScope) conditionSQL() (string, []interface{}) {
	var vals []interface{}
	conds := []string{}
	for _, condition := range scope.conditions {
		conds = append(conds, condition.ToSQL())
		vals = append(vals, condition.vals...)
	}
	return strings.Join(conds, " AND "), vals
}

func (scope internalScope) Eq(val interface{}) internalScope {
	c := condition{column: scope.currentColumn}
	if val == nil {
		c.cond = "IS NULL"
	} else {
		c.cond = "= ?"
		c.vals = []interface{}{val}
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Neq(val interface{}) internalScope {
	c := condition{column: scope.currentColumn}
	if val == nil {
		c.cond = "IS NOT NULL"
	} else {
		c.cond = "<> ?"
		c.vals = []interface{}{val}
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Gt(val interface{}) internalScope {
	c := condition{
		column: scope.currentColumn,
		cond:   "> ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Gte(val interface{}) internalScope {
	c := condition{
		column: scope.currentColumn,
		cond:   ">= ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Lt(val interface{}) internalScope {
	c := condition{
		column: scope.currentColumn,
		cond:   "< ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Lte(val interface{}) internalScope {

	c := condition{
		column: scope.currentColumn,
		cond:   "<= ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

// multi value conditions
func (scope internalScope) Between(lower, upper interface{}) internalScope {
	c := condition{
		column: scope.currentColumn,
		cond:   "BETWEEN ? AND ?",
		vals:   []interface{}{lower, upper},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) In(vals ...interface{}) internalScope {
	if len(vals) == 0 {
		if reflect.TypeOf(vals[0]).Kind() == reflect.Slice {
			rv := reflect.ValueOf(vals[0])
			vals = make([]interface{}, rv.Len())
			for i := 0; i < rv.Len(); i++ {
				vals[i] = rv.Index(i).Interface()
			}
		}
	}

	vc := make([]string, len(vals))
	c := condition{
		column: scope.currentColumn,
		cond:   "IN (" + strings.Join(vc, "?, ") + "?)",
		vals:   vals,
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) NotIn(vals ...interface{}) internalScope {
	vc := make([]string, len(vals))
	c := condition{
		column: scope.currentColumn,
		cond:   fmt.Sprintf("NOT IN (%!s(MISSING)?)", strings.Join(vc, "?, ")),
		vals:   vals,
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Like(str string) internalScope {
	c := condition{
		column: scope.currentColumn,
		cond:   "LIKE ?",
		vals:   []interface{}{str},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) Where(sql string, vals ...interface{}) internalScope {
	c := condition{
		cond: sql,
		vals: vals,
	}
	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope internalScope) outerJoin(name string, things ...Scope) internalScope {
	for _, thing := range things {
		thing.SetConn(scope.conn)
		if joinString, ok := scope.joinOn(name, thing); ok {
			scope.joins = append(scope.joins, fmt.Sprintf(
				"LEFT JOIN %s ON %s",
				thing.joinable(),
				joinString,
			))
			scope.joinedScopes = append(scope.joinedScopes, thing)
			continue
		} else {
			for _, joinscope := range scope.joinedScopes {
				if joinString, ok := joinscope.joinOn(name, thing); ok {
					scope.joins = append(scope.joins, fmt.Sprintf(
						"LEFT JOIN %s ON %s",
						thing.joinable(),
						joinString,
					))
					scope.joinedScopes = append(scope.joinedScopes, thing)
					continue
				}
			}
		}
		// error
	}
	return scope
}

func (scope internalScope) innerJoin(name string, things ...Scope) internalScope {
	for _, thing := range things {
		thing.SetConn(scope.conn)
		if joinString, ok := scope.joinOn(name, thing); ok {
			scope.joins = append(scope.joins, fmt.Sprintf(
				"INNER JOIN %s ON %s",
				thing.joinable(),
				joinString,
			))
			scope.conditions = append(scope.conditions, thing.conds()...)
			scope.joinedScopes = append(scope.joinedScopes, thing)
			continue
		} else {
			for _, joinscope := range scope.joinedScopes {
				if joinString, ok := joinscope.joinOn(name, thing); ok {
					scope.joins = append(scope.joins, fmt.Sprintf(
						"INNER JOIN %s ON %s",
						thing.joinable(),
						joinString,
					))
					scope.joinedScopes = append(scope.joinedScopes, thing)
					scope.conditions = append(scope.conditions, thing.conds()...)
					continue
				}
			}
		}
		// error
	}

	return scope
}

func (scope internalScope) joinOn(name string, joinee Scope) (string, bool) {
	ts := Schema.Tables[name]
	for _, hm := range ts.HasMany {
		if (hm.Parent.Name == name && hm.Child.Name == joinee.scopeName()) || hm.Parent.Name == name && hm.Child.Name == joinee.scopeName() {
			pkc := hm.Parent.PrimaryKeyColumn()
			return fmt.Sprintf(
				"%s.%s = %s.%s",
				scope.conn.SQLTable(hm.Parent.Name),
				scope.conn.SQLColumn(hm.Parent.Name, pkc.Name),
				scope.conn.SQLTable(hm.Child.Name),
				scope.conn.SQLColumn(hm.Child.Name, hm.ChildColumn.Name),
			), true
		}
	}
	for _, hm := range ts.ChildOf {
		if (hm.Parent.Name == name && hm.Child.Name == joinee.scopeName()) || hm.Parent.Name == name && hm.Child.Name == joinee.scopeName() {
			pkc := hm.Parent.PrimaryKeyColumn()
			return fmt.Sprintf(
				"%s.%s = %s.%s",
				scope.conn.SQLTable(hm.Parent.Name),
				scope.conn.SQLColumn(hm.Parent.Name, pkc.Name),
				scope.conn.SQLTable(hm.Child.Name),
				scope.conn.SQLColumn(hm.Child.Name, hm.ChildColumn.Name),
			), true
		}
	}
	for _, hm := range ts.HasOne {
		if (hm.Parent.Name == name && hm.Child.Name == joinee.scopeName()) || hm.Parent.Name == name && hm.Child.Name == joinee.scopeName() {
			pkc := hm.Parent.PrimaryKeyColumn()
			return fmt.Sprintf(
				"%s.%s = %s.%s",
				scope.conn.SQLTable(hm.Parent.Name),
				scope.conn.SQLColumn(hm.Parent.Name, pkc.Name),
				scope.conn.SQLTable(hm.Child.Name),
				scope.conn.SQLColumn(hm.Child.Name, hm.ChildColumn.Name),
			), true
		}
	}
	for _, hm := range ts.BelongsTo {
		if (hm.Parent.Name == name && hm.Child.Name == joinee.scopeName()) || hm.Parent.Name == name && hm.Child.Name == joinee.scopeName() {
			pkc := hm.Parent.PrimaryKeyColumn()
			return fmt.Sprintf(
				"%s.%s = %s.%s",
				scope.conn.SQLTable(hm.Parent.Name),
				scope.conn.SQLColumn(hm.Parent.Name, pkc.Name),
				scope.conn.SQLTable(hm.Child.Name),
				scope.conn.SQLColumn(hm.Child.Name, hm.ChildColumn.Name),
			), true
		}
	}
	return "", false
}

func (scope internalScope) PluckString() ([]string, error) {
	if scope.isDistinct {
		scope.currentColumn = "DISTINCT " + scope.currentColumn
	}
	scope.columns = []string{scope.currentColumn}
	ss, vv := scope.query()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		return []string{}, err
	}
	vals := []string{}
	defer rows.Close()
	for rows.Next() {
		var temp string
		err = rows.Scan(&temp)
		if err != nil {
			return []string{}, err
		}
		vals = append(vals, temp)
	}

	return vals, nil
}

func (scope internalScope) PluckInt() ([]int64, error) {
	if scope.isDistinct {
		scope.currentColumn = "DISTINCT " + scope.currentColumn
	}

	scope.columns = []string{scope.currentColumn}
	ss, vv := scope.query()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		return []int64{}, err
	}
	vals := []int64{}
	defer rows.Close()
	for rows.Next() {
		var temp int64
		err = rows.Scan(&temp)
		if err != nil {
			return []int64{}, err
		}
		vals = append(vals, temp)
	}

	return vals, nil
}

func (scope internalScope) PluckTime() ([]time.Time, error) {
	if scope.isDistinct {
		scope.currentColumn = "DISTINCT " + scope.currentColumn
	}

	scope.columns = []string{scope.currentColumn}
	ss, vv := scope.query()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		return []time.Time{}, err
	}
	vals := []time.Time{}
	defer rows.Close()
	for rows.Next() {
		var temp time.Time
		err = rows.Scan(&temp)
		if err != nil {
			return []time.Time{}, err
		}
		vals = append(vals, temp)
	}

	return vals, nil
}

func (scope internalScope) pluckStruct(name string, result interface{}) error {
	destSlice := reflect.ValueOf(result).Elem()
	tempSlice := reflect.Zero(destSlice.Type())
	elem := destSlice.Type().Elem()
	vn := reflect.New(elem)
	rfltr := reflector{vn}
	p := &planner{[]*reflectScanner{}}

	for i := 0; i < elem.NumField(); i++ {
		f := elem.Field(i)
		if f.Tag.Get("column") != "" {
			scope.columns = append(scope.columns, f.Tag.Get("column"))
		} else {
			scope.columns = append(
				scope.columns,
				fmt.Sprintf("%s.%s",
					scope.conn.SQLTable(name),
					scope.conn.SQLColumn(name, f.Name),
				),
			)
		}
		p.scanners = append(p.scanners, &reflectScanner{index: i, parent: rfltr, column: f})
	}

	ss, sv := scope.query()
	rows, err := scope.conn.Query(ss, sv...)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		err = rows.Scan(p.Items()...)
		if err != nil {
			return err
		}
		p.Finalize(vn.Interface())
		tempSlice = reflect.Append(tempSlice, vn.Elem())
		rfltr.item = reflect.New(elem)
	}
	destSlice.Set(tempSlice)

	return nil
}

type StringArray []string

func (sa StringArray) Includes(s string) bool {
	for _, si := range sa {
		if si == s {
			return true
		}
	}
	return false
}

type condition struct {
	column string
	cond   string
	vals   []interface{}
}

func (c condition) ToSQL() string {
	if c.column == "" {
		return c.cond
	}
	return c.column + " " + c.cond
}

func questions(n int) string {
	chars := make([]byte, n*2-1)
	for i, _ := range chars {
		if i%2 == 0 {
			chars[i] = '?'
		} else {
			chars[i] = ','
		}
	}
	return string(chars)
}

type planner struct {
	scanners []*reflectScanner
}

func (p *planner) Items() []interface{} {
	output := make([]interface{}, len(p.scanners))
	for i, _ := range output {
		output[i] = p.scanners[i].iface()
	}

	return output
}

type mixed interface {
	SetNull(string)
}

func (p *planner) Finalize(val interface{}) {
	for _, s := range p.scanners {
		if s.column.Type.Kind() == reflect.Ptr {
			s.finalize()
		}
	}
}

type reflectScanner struct {
	parent reflector
	column reflect.StructField
	index  int
	b      sql.NullBool
	f      sql.NullFloat64
	i      sql.NullInt64
	s      sql.NullString
	isnull bool
}

type reflector struct {
	item reflect.Value
}

func (rf *reflectScanner) iface() interface{} {
	if rf.column.Type.Kind() == reflect.Ptr {
		switch rf.column.Type.Elem().Kind() {
		case reflect.String:
			return &rf.s
		case reflect.Bool:
			return &rf.b
		case reflect.Float32, reflect.Float64:
			return &rf.f
		default:
			return &rf.i
		}
	} else {
		return rf.parent.item.Elem().Field(rf.index).Addr().Interface()
	}
}

func (rf *reflectScanner) finalize() bool {
	switch rf.column.Type.Kind() {
	case reflect.String:
		if rf.s.Valid {
			rf.parent.item.Elem().Field(rf.index).Set(reflect.ValueOf(&rf.s.String))
		} else {
			return true
		}
	case reflect.Bool:
		if rf.b.Valid {
			rf.parent.item.Elem().Field(rf.index).Set(reflect.ValueOf(&rf.b.Bool))
		} else {
			return true
		}
	case reflect.Float64:
		if rf.f.Valid {
			rf.parent.item.Elem().Field(rf.index).Set(reflect.ValueOf(&rf.f.Float64))
		} else {
			return true
		}
	case reflect.Float32:
		if rf.f.Valid {
			f := float32(rf.f.Float64)
			rf.parent.item.Elem().Field(rf.index).Set(reflect.ValueOf(f))
		} else {
			return true
		}
	case reflect.Int64:
		if rf.i.Valid {
			rf.parent.item.Elem().Field(rf.index).Set(reflect.ValueOf(&rf.i.Int64))
		} else {
			return true
		}
	case reflect.Int:
		if rf.i.Valid {
			i := int(rf.i.Int64)
			rf.parent.item.Elem().Field(rf.index).Set(reflect.ValueOf(&i))
		} else {
			return true
		}
	default:
		if rf.i.Valid {
			rf.parent.item.Elem().Field(rf.index).SetInt(rf.i.Int64)
		} else {
			return true
		}
	}
	return false
}
